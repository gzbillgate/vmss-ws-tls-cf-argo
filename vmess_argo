#!/bin/bash

#=============================================================================
#  Xray + Cloudflare Argo Tunnel 一键部署管理脚本
#  版本：v3.0 (Token 解析修复版)
#  修复：正确从 JWT Token 中提取 Tunnel ID
#=============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

SCRIPT_VERSION="3.0"
XRAY_VERSION=""
CF_VERSION=""
UUID=""
WS_PATH=""
XRAY_PORT=""
CF_DOMAIN=""
TUNNEL_ID=""
TUNNEL_NAME=""
TUNNEL_TOKEN=""
OS_PRETTY=""
ARCH=""
ARCH_NAME=""

log_info() { echo -e "${GREEN}[✓ INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[⚠ WARN]${NC} $1"; }
log_error() { echo -e "${RED}[✗ ERROR]${NC} $1"; }
log_step() { echo -e "${BLUE}[➤ STEP]${NC} $1"; }
log_success() { echo -e "${GREEN}[✓ SUCCESS]${NC} $1"; }
log_progress() { echo -e "${CYAN}[...]${NC} $1"; }

show_banner() {
    clear
    echo -e "${PURPLE}"
    echo "╔═══════════════════════════════════════════════════════════╗"
    echo "║     Xray + Cloudflare Argo Tunnel 一键部署管理系统        ║"
    echo "║                        版本：${SCRIPT_VERSION}                    ║"
    echo "╚═══════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        log_error "请使用 root 用户运行此脚本"
        exit 1
    fi
}

detect_system() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS_PRETTY=$PRETTY_NAME
    else
        OS_PRETTY="Unknown"
    fi
    
    ARCH_RAW=$(uname -m)
    case $ARCH_RAW in
        x86_64) ARCH="64"; ARCH_NAME="amd64" ;;
        aarch64|arm64) ARCH="arm64"; ARCH_NAME="arm64" ;;
        armv7l|armv7) ARCH="arm32-v7a"; ARCH_NAME="arm" ;;
        *) ARCH="64"; ARCH_NAME="amd64" ;;
    esac
    
    log_info "系统：$OS_PRETTY | 架构：$ARCH_RAW ($ARCH)"
}

detect_package_manager() {
    if command -v apt &> /dev/null; then
        PM="apt"; PM_UPDATE="apt update -y"; PM_INSTALL="apt install -y"
    elif command -v yum &> /dev/null; then
        PM="yum"; PM_UPDATE="yum update -y"; PM_INSTALL="yum install -y"
    elif command -v dnf &> /dev/null; then
        PM="dnf"; PM_UPDATE="dnf update -y"; PM_INSTALL="dnf install -y"
    else
        PM="apt"; PM_UPDATE="apt update -y"; PM_INSTALL="apt install -y"
    fi
}

check_installation_status() {
    XRAY_INSTALLED=false; CF_INSTALLED=false; XRAY_RUNNING=false; CF_RUNNING=false
    
    [ -f /usr/local/bin/xray ] && XRAY_INSTALLED=true && XRAY_VERSION=$(/usr/local/bin/xray version 2>/dev/null | head -1 || echo "未知")
    [ -f /usr/local/bin/cloudflared ] && CF_INSTALLED=true && CF_VERSION=$(/usr/local/bin/cloudflared version 2>/dev/null || echo "未知")
    systemctl is-active --quiet xray 2>/dev/null && XRAY_RUNNING=true
    systemctl is-active --quiet cloudflared 2>/dev/null && CF_RUNNING=true
    
    [ -f /etc/xray/config.json ] && {
        UUID=$(jq -r '.inbounds[0].settings.clients[0].id' /etc/xray/config.json 2>/dev/null || echo "")
        XRAY_PORT=$(jq -r '.inbounds[0].port' /etc/xray/config.json 2>/dev/null || echo "")
        WS_PATH=$(jq -r '.inbounds[0].streamSettings.wsSettings.path' /etc/xray/config.json 2>/dev/null | tr -d '/' || echo "")
    }
    [ -f /etc/cloudflared/config.yml ] && {
        CF_DOMAIN=$(grep 'hostname:' /etc/cloudflared/config.yml 2>/dev/null | awk '{print $2}' || echo "")
        TUNNEL_ID=$(cat /etc/cloudflared/tunnel-id 2>/dev/null || echo "")
    }
    [ -f /etc/cloudflared/token ] && TUNNEL_TOKEN=$(cat /etc/cloudflared/token 2>/dev/null || echo "")
}

install_dependencies() {
    log_step "安装系统依赖..."
    $PM_UPDATE >/dev/null 2>&1 || true
    $PM_INSTALL curl wget jq tar gzip unzip socat uuid-runtime >/dev/null 2>&1 || true
    log_success "依赖安装完成"
}

install_xray() {
    log_step "安装 Xray-core..."
    cd /tmp
    
    log_progress "获取最新版本..."
    LATEST_VERSION=$(curl -s https://api.github.com/repos/XTLS/Xray-core/releases/latest 2>/dev/null | grep '"tag_name"' | cut -d'"' -f4 || echo "v26.2.6")
    [ -z "$LATEST_VERSION" ] || ! echo "$LATEST_VERSION" | grep -qE '^v[0-9]+' && LATEST_VERSION="v26.2.6"
    
    log_info "使用版本：$LATEST_VERSION"
    local FILENAME="Xray-linux-${ARCH}.zip"
    local DOWNLOAD_URL="https://github.com/XTLS/Xray-core/releases/download/${LATEST_VERSION}/${FILENAME}"
    
    local MIRRORS=(
        "$DOWNLOAD_URL"
        "https://mirror.ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${LATEST_VERSION}/${FILENAME}"
        "https://ghproxy.com/https://github.com/XTLS/Xray-core/releases/download/${LATEST_VERSION}/${FILENAME}"
    )
    
    local DOWNLOAD_SUCCESS=false
    for URL in "${MIRRORS[@]}"; do
        log_progress "尝试：$URL"
        rm -f xray.zip
        if curl -sL --connect-timeout 30 --max-time 90 -o xray.zip "$URL" 2>/dev/null; then
            if [ -s xray.zip ] && unzip -t xray.zip >/dev/null 2>&1; then
                log_success "下载成功"
                DOWNLOAD_SUCCESS=true
                break
            fi
        fi
    done
    
    [ "$DOWNLOAD_SUCCESS" = false ] && { log_error "所有下载源都失败"; exit 1; }
    
    log_progress "解压安装..."
    unzip -q -o xray.zip
    mkdir -p /etc/xray /var/log/xray
    chmod +x xray 2>/dev/null || true
    mv -f xray /usr/local/bin/xray 2>/dev/null || true
    [ -f xray-core ] && { chmod +x xray-core 2>/dev/null || true; mv -f xray-core /usr/local/bin/xray-core 2>/dev/null || true; }
    mv -f geoip.dat /etc/xray/ 2>/dev/null || true
    mv -f geosite.dat /etc/xray/ 2>/dev/null || true
    rm -f xray.zip
    
    XRAY_VERSION=$(/usr/local/bin/xray version | head -1)
    log_success "Xray-core 安装完成：$XRAY_VERSION"
}

install_cloudflared() {
    log_step "安装 cloudflared..."
    case $ARCH in
        64) CF_ARCH="amd64" ;;
        arm64) CF_ARCH="arm64" ;;
        arm32-v7a) CF_ARCH="arm" ;;
        *) CF_ARCH="amd64" ;;
    esac
    
    local CF_URLS=(
        "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-${CF_ARCH}"
        "https://mirror.ghproxy.com/https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-${CF_ARCH}"
    )
    
    for URL in "${CF_URLS[@]}"; do
        log_progress "尝试：$URL"
        if curl -sL --connect-timeout 30 --max-time 60 -o /tmp/cloudflared "$URL" 2>/dev/null; then
            if [ -s /tmp/cloudflared ]; then
                chmod +x /tmp/cloudflared
                mv -f /tmp/cloudflared /usr/local/bin/cloudflared
                CF_VERSION=$(/usr/local/bin/cloudflared version)
                log_success "cloudflared 安装完成：$CF_VERSION"
                return 0
            fi
        fi
    done
    log_error "cloudflared 下载失败"
    exit 1
}

generate_uuid() {
    if command -v uuidgen &> /dev/null; then
        uuidgen | tr '[:upper:]' '[:lower:]'
    elif command -v uuid &> /dev/null; then
        uuid | tr '[:upper:]' '[:lower:]'
    else
        cat /proc/sys/kernel/random/uuid
    fi
}

# 【修复】正确解析 JWT Token 获取 Tunnel ID
extract_tunnel_id_from_token() {
    local TOKEN=$1
    local TUNNEL_ID=""
    
    # JWT Token 格式：header.payload.signature
    # payload 部分包含 tunnel_id
    local PAYLOAD=$(echo "$TOKEN" | cut -d'.' -f2)
    
    # 添加 padding（base64 URL safe）
    local MOD=$((4 - ${#PAYLOAD} % 4))
    if [ $MOD -ne 4 ]; then
        PAYLOAD="${PAYLOAD}$(printf '=%.0s' $(seq 1 $MOD))"
    fi
    
    # 替换 URL safe 字符
    PAYLOAD=$(echo "$PAYLOAD" | tr '_-' '/+')
    
    # 解码并提取 tunnel_id
    local DECODED=$(echo "$PAYLOAD" | base64 -d 2>/dev/null)
    
    # 尝试多种字段名
    TUNNEL_ID=$(echo "$DECODED" | grep -oP '"tunnel_id"\s*:\s*"\K[a-f0-9-]+' | head -1)
    [ -z "$TUNNEL_ID" ] && TUNNEL_ID=$(echo "$DECODED" | grep -oP '"tun"\s*:\s*"\K[a-f0-9-]+' | head -1)
    [ -z "$TUNNEL_ID" ] && TUNNEL_ID=$(echo "$DECODED" | grep -oP '"id"\s*:\s*"\K[a-f0-9-]+' | head -1)
    
    echo "$TUNNEL_ID"
}

create_xray_config() {
    log_step "创建 Xray 配置文件..."
    cat > /etc/xray/config.json << EOF
{
    "log": {
        "loglevel": "warning",
        "access": "/var/log/xray/access.log",
        "error": "/var/log/xray/error.log"
    },
    "inbounds": [
        {
            "port": ${XRAY_PORT},
            "protocol": "vmess",
            "settings": {
                "clients": [
                    {
                        "id": "${UUID}",
                        "alterId": 0,
                        "email": "user@vmess.local",
                        "level": 1
                    }
                ],
                "disableInsecureEncryption": false
            },
            "streamSettings": {
                "network": "ws",
                "wsSettings": {
                    "path": "/${WS_PATH}"
                }
            },
            "sniffing": {
                "enabled": true,
                "destOverride": ["http", "tls"]
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom",
            "settings": {}
        },
        {
            "protocol": "blackhole",
            "settings": {},
            "tag": "blocked"
        }
    ],
    "routing": {
        "rules": [
            {
                "type": "field",
                "ip": ["geoip:private"],
                "outboundTag": "blocked"
            }
        ]
    }
}
EOF
    log_success "Xray 配置文件创建完成"
}

# 【修复】Token 认证，正确提取 Tunnel ID
cloudflare_auth_token() {
    log_step "Cloudflare Token 认证..."
    echo ""
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  ${WHITE}Cloudflare Token 认证（无需浏览器）${NC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo "  获取 Token 步骤："
    echo "  1. 访问：https://one.dash.cloudflare.com/"
    echo "  2. Access → Tunnels → Create a tunnel"
    echo "  3. 复制 Token（以 eyJ 开头的长字符串）"
    echo ""
    echo -n "  请输入 Token: "
    read TUNNEL_TOKEN
    
    if [ -z "$TUNNEL_TOKEN" ]; then
        log_error "Token 不能为空"
        return 1
    fi
    
    # 保存 Token
    mkdir -p /etc/cloudflared
    echo "$TUNNEL_TOKEN" > /etc/cloudflared/token
    chmod 600 /etc/cloudflared/token
    
    # 提取 Tunnel ID
    log_progress "解析 Token..."
    TUNNEL_ID=$(extract_tunnel_id_from_token "$TUNNEL_TOKEN")
    
    if [ -n "$TUNNEL_ID" ]; then
        echo "$TUNNEL_ID" > /etc/cloudflared/tunnel-id
        log_success "Tunnel ID: $TUNNEL_ID"
    else
        log_warn "无法从 Token 中提取 Tunnel ID，请在 Cloudflare 后台查看"
        echo ""
        echo "  请手动输入 Tunnel ID（可选）："
        echo -n "  Tunnel ID: "
        read MANUAL_ID
        [ -n "$MANUAL_ID" ] && echo "$MANUAL_ID" > /etc/cloudflared/tunnel-id && TUNNEL_ID=$MANUAL_ID
    fi
    
    log_success "Token 认证完成"
}

cloudflare_auth_browser() {
    log_step "Cloudflare 浏览器认证..."
    echo ""
    echo "  即将运行认证命令..."
    echo ""
    echo -n "  按回车键继续..."
    read
    
    /usr/local/bin/cloudflared tunnel login
    
    if [ -f ~/.cloudflared/cert.pem ]; then
        cp ~/.cloudflared/cert.pem /etc/cloudflared/cert.pem
        log_success "Cloudflare 认证完成"
    else
        log_error "认证失败"
        return 1
    fi
}

create_tunnel() {
    log_step "创建 Cloudflare 隧道..."
    
    if [ -n "$TUNNEL_TOKEN" ]; then
        log_info "使用 Token 配置，跳过隧道创建"
        return 0
    fi
    
    /usr/local/bin/cloudflared tunnel delete "$TUNNEL_NAME" 2>/dev/null || true
    
    TUNNEL_OUTPUT=$(/usr/local/bin/cloudflared tunnel create "$TUNNEL_NAME" 2>&1)
    TUNNEL_ID=$(echo "$TUNNEL_OUTPUT" | grep -oP 'Created tunnel \K[a-f0-9-]+' || echo "")
    
    if [ -z "$TUNNEL_ID" ]; then
        log_error "创建隧道失败"
        return 1
    fi
    
    echo "$TUNNEL_ID" > /etc/cloudflared/tunnel-id
    CRED_FILE=$(echo "$TUNNEL_OUTPUT" | grep -oP '/[^ ]+\.json' | head -1 || echo "")
    [ -n "$CRED_FILE" ] && [ -f "$CRED_FILE" ] && cp "$CRED_FILE" /etc/cloudflared/${TUNNEL_ID}.json
    
    log_success "隧道创建完成：$TUNNEL_ID"
}

create_cloudflared_config() {
    log_step "创建 cloudflared 配置文件..."
    mkdir -p /etc/cloudflared
    
    cat > /etc/cloudflared/config.yml << EOF
tunnel: ${TUNNEL_ID}
credentials-file: /root/.cloudflared/${TUNNEL_ID}.json

metrics: 0.0.0.0:2000
no-autoupdate: true

ingress:
  - hostname: ${CF_DOMAIN}
    service: http://localhost:${XRAY_PORT}
  - service: http_status:404
EOF
    
    log_success "cloudflared 配置文件创建完成"
}

create_systemd_services() {
    log_step "创建 systemd 服务..."
    
    if [ -n "$TUNNEL_TOKEN" ]; then
        cat > /etc/systemd/system/cloudflared.service << EOF
[Unit]
Description=Cloudflare Tunnel Service
After=network.target xray.service

[Service]
Type=simple
User=root
ExecStart=/usr/local/bin/cloudflared tunnel run --token ${TUNNEL_TOKEN}
Restart=on-failure
RestartSec=5s
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
    else
        cat > /etc/systemd/system/cloudflared.service << EOF
[Unit]
Description=Cloudflare Tunnel Service
After=network.target xray.service

[Service]
Type=simple
User=root
ExecStart=/usr/local/bin/cloudflared tunnel run
Restart=on-failure
RestartSec=5s
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
    fi
    
    cat > /etc/systemd/system/xray.service << EOF
[Unit]
Description=Xray Service
After=network.target

[Service]
Type=simple
User=root
ExecStart=/usr/local/bin/xray run -config /etc/xray/config.json
Restart=on-failure
RestartSec=5s
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl daemon-reload
    systemctl enable xray >/dev/null 2>&1 || true
    systemctl enable cloudflared >/dev/null 2>&1 || true
    log_success "systemd 服务创建完成"
}

configure_dns() {
    log_step "配置 DNS 记录..."
    if [ -z "$TUNNEL_TOKEN" ]; then
        /usr/local/bin/cloudflared tunnel route dns "$TUNNEL_ID" "$CF_DOMAIN" 2>/dev/null || {
            log_warn "DNS 记录创建失败，请在 Cloudflare 后台手动添加"
        }
    else
        log_info "Token 模式请在 Cloudflare 后台配置 DNS"
    fi
    log_success "DNS 配置完成"
}

start_services() {
    log_step "启动服务..."
    systemctl start xray
    sleep 2
    systemctl start cloudflared
    sleep 2
    
    if systemctl is-active --quiet xray && systemctl is-active --quiet cloudflared; then
        log_success "所有服务启动成功"
    else
        log_warn "部分服务启动失败，请检查日志"
    fi
}

stop_services() {
    systemctl stop cloudflared 2>/dev/null || true
    systemctl stop xray 2>/dev/null || true
    log_success "服务已停止"
}

restart_services() {
    systemctl restart xray
    systemctl restart cloudflared
    log_success "服务已重启"
}

show_config() {
    echo ""
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  ${WHITE}节点配置信息${NC}"
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo -e "${CYAN}【Xray 配置】${NC}"
    echo "  UUID:     ${UUID}"
    echo "  端口：     ${XRAY_PORT}"
    echo "  路径：     /${WS_PATH}"
    echo ""
    echo -e "${CYAN}【Cloudflare 配置】${NC}"
    echo "  域名：     ${CF_DOMAIN}"
    echo "  隧道 ID:   ${TUNNEL_ID}"
    echo ""
    echo -e "${CYAN}【客户端配置】${NC}"
    echo "  地址：     ${CF_DOMAIN}"
    echo "  端口：     443"
    echo "  协议：     vmess"
    echo "  传输：     ws+tls"
    echo "  路径：     /${WS_PATH}"
    echo "  UUID:      ${UUID}"
    echo ""
    
    local VMESS_JSON="{\"v\":\"2\",\"ps\":\"CF-Argo\",\"add\":\"${CF_DOMAIN}\",\"port\":\"443\",\"id\":\"${UUID}\",\"aid\":\"0\",\"net\":\"ws\",\"type\":\"none\",\"host\":\"${CF_DOMAIN}\",\"path\":\"/${WS_PATH}\",\"tls\":\"tls\"}"
    local VMESS_LINK="vmess://$(echo -n "$VMESS_JSON" | base64 -w 0)"
    
    echo -e "${CYAN}【vmess 链接】${NC}"
    echo "  $VMESS_LINK"
    echo ""
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

show_status() {
    echo ""
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  ${WHITE}服务状态${NC}"
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    
    [ "$XRAY_INSTALLED" = true ] && echo -e "  ${GREEN}✓${NC} Xray-core:     已安装 (${XRAY_VERSION})" || echo -e "  ${RED}✗${NC} Xray-core:     未安装"
    [ "$XRAY_RUNNING" = true ] && echo -e "  ${GREEN}✓${NC} Xray 服务：    运行中" || echo -e "  ${YELLOW}⚠${NC} Xray 服务：    未运行"
    [ "$CF_INSTALLED" = true ] && echo -e "  ${GREEN}✓${NC} cloudflared:   已安装 (${CF_VERSION})" || echo -e "  ${RED}✗${NC} cloudflared:   未安装"
    [ "$CF_RUNNING" = true ] && echo -e "  ${GREEN}✓${NC} Tunnel 服务：  运行中" || echo -e "  ${YELLOW}⚠${NC} Tunnel 服务：  未运行"
    
    echo ""
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

view_logs() {
    echo ""
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  ${WHITE}日志查看${NC}"
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo "  1) Xray 日志  2) cloudflared 日志  3) Xray 错误日志  4) 返回"
    echo ""
    echo -n "  请选择 (1-4): "
    read LOG_OPTION
    
    case $LOG_OPTION in
        1) tail -20 /var/log/xray/access.log 2>/dev/null || echo "日志不存在" ;;
        2) journalctl -u cloudflared -n 20 --no-pager 2>/dev/null || echo "日志不可用" ;;
        3) tail -20 /var/log/xray/error.log 2>/dev/null || echo "日志不存在" ;;
        4) return ;;
        *) log_warn "无效选项" ;;
    esac
    echo ""
    echo -n "  按回车键返回..."
    read
}

update_components() {
    echo ""
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  ${WHITE}组件更新${NC}"
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo "  1) 更新 Xray-core  2) 更新 cloudflared  3) 更新全部  4) 返回"
    echo ""
    echo -n "  请选择 (1-4): "
    read UPDATE_OPTION
    
    case $UPDATE_OPTION in
        1) stop_services; install_xray; start_services; log_success "Xray 更新完成" ;;
        2) systemctl stop cloudflared; install_cloudflared; systemctl start cloudflared; log_success "cloudflared 更新完成" ;;
        3) stop_services; install_xray; install_cloudflared; start_services; log_success "全部更新完成" ;;
        4) return ;;
        *) log_warn "无效选项" ;;
    esac
    echo ""
    echo -n "  按回车键返回..."
    read
}

uninstall_all() {
    echo ""
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  ${WHITE}⚠  警告：此操作将卸载所有组件并删除配置${NC}"
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo -n "  确定要卸载吗？(输入 yes 确认): "
    read CONFIRM
    
    [ "$CONFIRM" != "yes" ] && { log_info "取消卸载"; return; }
    
    log_step "开始卸载..."
    systemctl stop cloudflared xray 2>/dev/null || true
    systemctl disable cloudflared xray 2>/dev/null || true
    rm -f /etc/systemd/system/{xray,cloudflared}.service
    rm -f /usr/local/bin/{xray,xray-core,cloudflared}
    rm -rf /etc/{xray,cloudflared} /var/log/{xray,cloudflared} ~/.cloudflared
    systemctl daemon-reload
    log_success "卸载完成！"
    echo -e "${YELLOW}请手动清理 Cloudflare 后台的 Tunnel 和 DNS 记录${NC}"
    echo -n "  按回车键返回..."
    read
}

full_deploy() {
    echo ""
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  ${WHITE}全新部署${NC}"
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    
    if [ "$XRAY_INSTALLED" = true ] || [ "$CF_INSTALLED" = true ]; then
        log_warn "检测到已有组件安装"
        echo -n "  是否继续？(y/n): "
        read CONTINUE
        [ "$CONTINUE" != "y" ] && [ "$CONTINUE" != "Y" ] && return
    fi
    
    echo ""
    echo -e "${CYAN}请输入配置信息:${NC}"
    echo ""
    echo -n "  Cloudflare 域名 (例如：app.example.com): "
    read CF_DOMAIN
    echo -n "  Xray 监听端口 (默认：10000): "
    read XRAY_PORT_INPUT; XRAY_PORT=${XRAY_PORT_INPUT:-10000}
    echo -n "  WS 路径 (默认：ray): "
    read WS_PATH_INPUT; WS_PATH=$(echo "$WS_PATH_INPUT" | tr -d '/' | sed 's/^$/ray/')
    echo -n "  隧道名称 (默认：my-tunnel): "
    read TUNNEL_NAME_INPUT; TUNNEL_NAME=${TUNNEL_NAME_INPUT:-my-tunnel}
    echo -n "  UUID (留空自动生成): "
    read UUID_INPUT
    [ -z "$UUID_INPUT" ] && { UUID=$(generate_uuid); log_info "自动生成 UUID"; } || UUID=$UUID_INPUT
    
    echo ""
    echo -e "${CYAN}选择认证方式:${NC}"
    echo "  1) Token 认证（推荐，无需浏览器）"
    echo "  2) 浏览器认证"
    echo -n "  请选择 (1-2): "
    read AUTH_METHOD
    
    log_step "开始部署..."
    
    detect_system
    detect_package_manager
    install_dependencies
    install_xray
    install_cloudflared
    create_xray_config
    
    if [ "$AUTH_METHOD" = "1" ]; then
        cloudflare_auth_token
    else
        cloudflare_auth_browser
    fi
    
    create_tunnel
    create_cloudflared_config
    configure_dns
    create_systemd_services
    start_services
    
    show_config
    log_success "部署完成！"
    echo -n "  按回车键返回..."
    read
}

main_menu() {
    while true; do
        show_banner
        check_installation_status
        
        echo -e "  ${CYAN}系统信息:${NC}  $OS_PRETTY | $ARCH_NAME"
        echo ""
        echo -e "  ${CYAN}安装状态:${NC}"
        [ "$XRAY_INSTALLED" = true ] && echo -e "    ${GREEN}✓${NC} Xray-core: ${XRAY_VERSION}" || echo -e "    ${RED}✗${NC} Xray-core: 未安装"
        [ "$CF_INSTALLED" = true ] && echo -e "    ${GREEN}✓${NC} cloudflared: ${CF_VERSION}" || echo -e "    ${RED}✗${NC} cloudflared: 未安装"
        echo ""
        echo -e "  ${CYAN}运行状态:${NC}"
        [ "$XRAY_RUNNING" = true ] && echo -e "    ${GREEN}✓${NC} Xray: 运行中" || echo -e "    ${YELLOW}⚠${NC} Xray: 未运行"
        [ "$CF_RUNNING" = true ] && echo -e "    ${GREEN}✓${NC} Tunnel: 运行中" || echo -e "    ${YELLOW}⚠${NC} Tunnel: 未运行"
        
        echo ""
        echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo "    1) 全新部署   2) 查看配置   3) 查看状态   4) 启动服务"
        echo "    5) 停止服务   6) 重启服务   7) 查看日志   8) 更新组件"
        echo "    9) 一键卸载   0) 退出脚本"
        echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -n "  请选择 (0-9): "
        read OPTION
        
        case $OPTION in
            1) full_deploy ;;
            2) [ -n "$UUID" ] && show_config || log_warn "未找到配置"; echo -n "  按回车返回..."; read ;;
            3) show_status; echo -n "  按回车返回..."; read ;;
            4) start_services; echo -n "  按回车返回..."; read ;;
            5) stop_services; echo -n "  按回车返回..."; read ;;
            6) restart_services; echo -n "  按回车返回..."; read ;;
            7) view_logs ;;
            8) update_components ;;
            9) uninstall_all ;;
            0) log_info "感谢使用，再见！"; exit 0 ;;
            *) log_warn "无效选项"; sleep 1 ;;
        esac
    done
}

main() {
    check_root
    detect_system
    detect_package_manager
    check_installation_status
    main_menu
}

main "$@"
